<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[CS 개념] 운영체제 (2) | 마포알라바 블로그</title><meta name=keywords content="CS,Coumputer Science,OS"><meta name=description content="Desc Text."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mapoalaba.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mapoalaba.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mapoalaba.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mapoalaba.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mapoalaba.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[CS 개념] 운영체제 (2)"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="https://mapoalaba.github.io/posts/cs-01/"><meta property="og:image" content="https://mapoalaba.github.io/cover/CS.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-20T11:30:03+00:00"><meta property="article:modified_time" content="2023-05-20T11:30:03+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mapoalaba.github.io/cover/CS.png"><meta name=twitter:title content="[CS 개념] 운영체제 (2)"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mapoalaba.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[CS 개념] 운영체제 (2)","item":"https://mapoalaba.github.io/posts/cs-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[CS 개념] 운영체제 (2)","name":"[CS 개념] 운영체제 (2)","description":"Desc Text.","keywords":["CS","Coumputer Science","OS"],"articleBody":"프로그램 어떤 작업을 위해 실행할 수 있는 파일 프로세스 컴퓨터에서 연속적으로 실행되고 있는 프로그램 동적인 개념으로는 실행된 프로그램을 의미 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것 운영체제로부터 시스템 자원(주소 공간, 파일, 메모리 등)을 할당받는 작업의 단위 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체) 프로세스 실행 중에 동적으로 할당되는 메모리인 메모리 힙을 포함 프로그램과 프로세스는 다름 프로그램은 명령어를 내용으로 가진 디스크에 저장된 파일, 수동적인 존재(passive entity) 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 능동적 존재(active entity) 실행 파일이 메모리에 적재될 때 프로그램이 프로세스가 되는 것 할당받는 자원의 예 CPU 시간 운영되기 위해 필요한 주소 공간 Code, Data, Stack, Heap의 구조로 되어 있는 독립적인 메모리 영역 특징 프로세스는 각각의 독립적인 메모리 영역(Code,Data, Stack,Heap의 구조)를 할당 Code : 프로그램을 실행시키는 실행 파일 내의 명령어(소스코드) Data : 전역변수, static 변수의 할당 Heap : 동적할당을 위한 메모리 영역 Stack : 지역변수, 함수 호출 시 전달되는 피라미터를 위한 메모리 영역 각 프로세스는 별도의 주소 공간에서 실행, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근❌ 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process, Communication)을 사용 파이프, 파일, 소켓 등을 사용 상태(state) new : 프로세스가 처음 생성되었을 때 ready : 프로세서에게 할당되기를 기다리는 상태 running : 프로세서에 할당되어 실행되는 상태, CPU를 차지하고 있음 waiting : 작업이 완료되어 입출력을 기다리는 상태 terminated : 실행이 종료되어 프로세스 모드가 끝난 상태 프로세스 제어 블록(Process Control Block, PCB) 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스의 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환, 이때의 모든 작업을 PCB에 저장 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행 저장되는 정보 프로세스 식별자(Process ID, PID) : 프로세스 식별 번호 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장 프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어의 주소 CPU 레지스터 CPU 스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터 등 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록 회계(Accounting) 정보 : 사용된 CPU 양과 시간, 시간 제한, 계정 번호 등 입출력 상태 정보 : 프로세스에 할당된 입출력장치들과 열린 파일의 목록 등 프로세스간 통신(IPC, Interprocess Communication) 서로 다른 두 개의 프로세스가 정보를 주고 받는 방식 실행중인 다른 프로세스들에게 영향을 주거나 받지 않는 독립적인 프로세스, 다른 프로세스들에게 영향을 주거나 받는 협력적인 프로세스가 존재\nIPC기법을 통해 협력적인 프로세스들은 테이터와 정보를 교환\n공유 메모리 시스템(Shared Memory) 기본적으로 프로세스는 서로의 영역에 침범할 수 없지만 프로세스가 이 제약조건을 제거하는 것에 동의하고 공유 영역에 글을 써 정보를 교환하는 방식\n공유 메모리 세그먼트를 생성하는 프로세스의 주소공간에 위치시켜 통신하고자 하는 다른 프로세스들이 이 세그먼트를 자신의 주소공간에 추가하는 방법으로 사용, 동시에 공유 버퍼를 접근하는 상황때문에 동기화를 고려해야 함\n메시지 전달 시스템(Message-Passing Systems) 커널을 통해 메세지를 교환하기 때문에 별도의 코드를 구축할 필요가 없어 구현이 쉽지만 컨택스트 스위칭이 발생하기 때문에 속도가 느리다는 단점이 존재\n스레드(Thread) 한 프로세스 내에서 실행되는 여러 흐름의 단위 프로세스의 특정한 수행 경로 프로세스가 할당받은 자원을 이용하는 실행의 단위, CPU 이용의 기본 단위 프로세스 내의 주소 공간이나 자원을 공유 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 같은 운영체제 자원 공유 하나의 프로세스를 다수의 실행단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상하는 것 == 멀티 스레딩 각각의 스레드는 독립적인 작업을 수행해야하기 때문에 각자의 스택과 PC 레지스터를 가진다. 특징 스레드는 프로세스 내에서 각각 Stack과 레지스터를 따로 할당받고 Code, Data, Heap 영역은 공유 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(Sibling Thread)도 그 변경 결과를 즉시 확인이 가능 분류 권한이 없는 스레드가 시스템 호출을 이용할 수 없도록 막기위해 종류를 나눔 사용자 수준의 스레드(User Threads)\n사용자가 만든 라이브러리를 사용하여 스레드를 운용 속도는 빠르지만 구현의 어려움 시스템 호출 권한이 없는 스레드 커널 수준의 스레드(Kernal Threads)\n운영체제 커널에 의해 스레드를 운용 구현은 쉽지만 유저 모드에서 커널 모드로 계속 바꿔줘야 하기 때문에 속도가 느림 시스템 호출 권한이 있는 스레드 ❓스택을 스레드마다 독립적으로 할당하는 이유는❓ 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것 ==\u003e 독립적인 실행 흐름의 추가 따라서, 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 제공 ❓PC Register를 스레드마다 독립적으로 할당하는 이유는❓ PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타냄 스레드는 CPU를 할당 받았다가 스케줄러에 의해 다시 선점당하는데, 이 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행됐는지 기록을 해야함 스레드 풀(Thread Pools) 웹 서버는 요청을 받을 때마다 요청을 위해 새로운 스레드를 생성 프로세스를 시작할 때, 일정한 수의 스레드를 미리 풀로 만들어 두는 것 평소에는 기다리다가 요청이 들어오면 풀의 한 스레드에게 서비스 요청을 할당 요청이 끝나면 스레드는 다시 풀로 돌아가 다음 작업을 대기 다중 스레드 서버의 문제점 서비스할 때마다 스레드를 생성하는데 시간이 소요 스레드는 주어진 일만 끝나게 되면 곧장 폐기되기 때문에 더욱 낭비 모든 요청마다 새로운 스레드를 만들어 서비스 한다면 동시에 실행할 수 있는 최대 스레드의 한계를 정해야 함 무한정 생성시 CPU 시간, 메모라 공건 등 시스템 자원이 고갈 장점 새 스레드를 만들어 주는 것보다 기존 스레드로 서비스 하는 것이 더 빠름 스레드 풀은 임의 시각에 존재할 수 있는 스레드 개수에 제한하기에 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 됨 자바 스레드(Java Thread) 일반 스레드와 거의 차이가 없으며, JVM(Java Virtual Machine)이 운영체제 역할 JVM : OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게하는 가상 컴퓨터이다.\n자바에는 프로세스 단위❌, 스레드만 존재 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록 스레드와 관련된 많은 정보들도 JVM에 의해 관리 스레드의 개수 스레드로 실행되는 프로그램 코드의 메모리 위치 스레드의 상태 우선순위 등 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행하도록 JVM에 요청 왜 멀티 프로세스 대신 멀티 스레드를 사용??? 간단히 설명하자면 프로그램을 여러개 켜는 것보다 하나의 프로그램에서 여러 작업을 하는 것!!!\n응답성 증가\n프로그램의 일부분이 봉쇄되거나, 긴 작업을 실행하더라도 프로그램의 실행이 계속되는 것을 허용함으로써 사용자에 대한 응답성을 증가 ex) 웹 브라우저는 한 스레드가 이미지 파일을 로드하고 있는 동안 다른 스레드에서 사용자와의 상호작용\n자원 공유 : 자원의 효율성 증가\n프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능 프로세스 간의 Context Switching시 단순히 CPU 레지스터만 교체하는 것이 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화하기 때문에 오버헤드가 큼 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간의 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 감소 코드와 데이터를 공유하면 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드 보유 가능 경제성 : 처리 비용 감소\n프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간의 통신 부담이 감소 스레드는 Stack 영역을 제외한 모든 메모리 공유 프로세스 생성을 위해 메모리와 자원을 할당하는 것보다 스레드를 생성하고 문맥 교환을 하는 것이 더 경제적 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠름 Context Switching 시 스레드는 Stack 영역만 처리!, 캐시 메모리는 비우지 않아도 됨 스레드가 프로세스보다 경량이기 때문에 생성과 제거가 쉽다 규모 가변성(Scalability)\n다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 실행 가능 멀티 스레드에서 주의할 점 동기화 문제\n스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 사용시 충돌 발생 가능 사용 중인 변수나 자료구조에 접근하여 잘못된 값을 읽어오거나 수정할 수 있음 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤해야 함 But, 병목 현상이 발생해 성능 저하 가능성 있음\n멀티 스레드는 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점을 가지고 있지만, 오류로 인해 하나의 스레드가 종료 시 전체 스레드가 종료될 수 있음\nContext CPU가 해당 프로세스를 실행하기 위한 해당 프로세스들의 정보\n프로세스의 PCB에 저장함\nContext Switching 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 상태의 Task의 저장된 상태 값을 읽어 복구하는 작업\nContext Switcjing이 진행되는 동안 시스템은 아무런 유용한 일도 하지 못하기 때문에 순수한 오버헤드\n이유 하나의 Task만 처리할 수 있다면?\n해당 Task가 끝날 때까지 기다려야 함 반응 속도가 느리고 사용하기 불편함 동시에 사용하는 것처럼 하기 위해\nComputer Multitasking 빠른 속도로 Task를 바꿔가며 실행하기 때문에 사람의 눈으로는 실시간처럼 보임 CPU가 Task를 바꿔가며 실행하기 위해 Context Switching이 필요 과정 Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리 현재 실행하고 있는 Task의 PCB 정보를 저장(Process Stack, Ready Queue) 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행 Context Switching Cost 많은 Cost가 필요\nCache 초기화 Memory Mapping 초기화 Kernel은 항상 실행되어야 함(메모리의 접근을 막기 위해) Process vs Thread\nProcess Context switching Cost \u003e Thread Context Switching Cost Thread는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 수행시 Stack 영역만 변경하면 되기 때문에 비용이 적음 ","wordCount":"1387","inLanguage":"en","image":"https://mapoalaba.github.io/cover/CS.png","datePublished":"2023-05-20T11:30:03Z","dateModified":"2023-05-20T11:30:03Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mapoalaba.github.io/posts/cs-01/"},"publisher":{"@type":"Organization","name":"마포알라바 블로그","logo":{"@type":"ImageObject","url":"https://mapoalaba.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mapoalaba.github.io/ accesskey=h title="MaPoAlaba (Alt + H)"><img src=https://mapoalaba.github.io/apple-touch-icon.png alt aria-label=logo height=35>MaPoAlaba</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mapoalaba.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://mapoalaba.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://mapoalaba.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://mapoalaba.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mapoalaba.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://mapoalaba.github.io/posts/>Posts</a></div><h1 class=post-title>[CS 개념] 운영체제 (2)</h1><div class=post-description>Desc Text.</div><div class=post-meta><span title='2023-05-20 11:30:03 +0000 +0000'>May 20, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1387 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/CS-01.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://mapoalaba.github.io/cover/CS.png alt><p></p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#할당받는-자원의-예>할당받는 자원의 예</a></li><li><a href=#특징>특징</a><ul><li><a href=#상태state>상태(state)</a></li></ul></li></ul><ul><li><a href=#저장되는-정보>저장되는 정보</a></li></ul><ul><li><a href=#공유-메모리-시스템shared-memory>공유 메모리 시스템(Shared Memory)</a></li><li><a href=#메시지-전달-시스템message-passing-systems>메시지 전달 시스템(Message-Passing Systems)</a></li></ul><ul><li><a href=#특징-1>특징</a></li><li><a href=#분류>분류</a></li></ul><ul><li><a href=#다중-스레드-서버의-문제점>다중 스레드 서버의 문제점</a></li><li><a href=#장점>장점</a></li></ul><ul><li><a href=#멀티-스레드에서-주의할-점>멀티 스레드에서 주의할 점</a></li></ul><ul><li><a href=#이유>이유</a></li><li><a href=#과정>과정</a></li><li><a href=#context-switching-cost>Context Switching Cost</a></li></ul></nav></div></details></div><div class=post-content><h1 id=프로그램>프로그램<a hidden class=anchor aria-hidden=true href=#프로그램>#</a></h1><pre><code>    어떤 작업을 위해 실행할 수 있는 파일
</code></pre><hr><h1 id=프로세스>프로세스<a hidden class=anchor aria-hidden=true href=#프로세스>#</a></h1><pre><code>    컴퓨터에서 연속적으로 실행되고 있는 프로그램
</code></pre><p><img loading=lazy src=https://velog.velcdn.com/images%2Fkoreanhole%2Fpost%2Ff27d4eef-8643-42f9-a4be-0ba07e87a517%2FUntitled.png alt=process></p><hr><ul><li>동적인 개념으로는 실행된 프로그램을 의미</li><li>디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것</li><li>운영체제로부터 시스템 자원(주소 공간, 파일, 메모리 등)을 할당받는 작업의 단위</li><li>함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 <code>프로세스 스택</code>과 전역 변수들을 수록하는 <code>데이터 섹션</code>을 포함</li><li>메모리에 올라와 실행되고 있는 <code>프로그램의 인스턴스(독립적인 개체)</code></li><li>프로세스 실행 중에 동적으로 할당되는 메모리인 <code>메모리 힙</code>을 포함</li><li>프로그램과 프로세스는 다름<ul><li>프로그램은 명령어를 내용으로 가진 디스크에 저장된 파일, <code>수동적인 존재(passive entity)</code></li><li>프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 <code>능동적 존재(active entity)</code></li><li>실행 파일이 <code>메모리에 적재될 때</code> 프로그램이 프로세스가 되는 것</li></ul></li></ul><hr><h2 id=할당받는-자원의-예>할당받는 자원의 예<a hidden class=anchor aria-hidden=true href=#할당받는-자원의-예>#</a></h2><ul><li>CPU 시간</li><li>운영되기 위해 필요한 주소 공간</li><li>Code, Data, Stack, Heap의 구조로 되어 있는 독립적인 메모리 영역</li></ul><hr><h2 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h2><ul><li>프로세스는 각각의 독립적인 메모리 영역(Code,Data, Stack,Heap의 구조)를 할당<ul><li>Code : 프로그램을 실행시키는 실행 파일 내의 명령어(소스코드)</li><li>Data : 전역변수, static 변수의 할당</li><li>Heap : 동적할당을 위한 메모리 영역</li><li>Stack : 지역변수, 함수 호출 시 전달되는 피라미터를 위한 메모리 영역</li></ul></li><li>각 프로세스는 별도의 주소 공간에서 실행, 한 프로세스는 <code>다른 프로세스의 변수나 자료구조에 접근❌</code></li><li>한 프로세스가 다른 프로세스의 자원에 접근하려면 <code>프로세스 간의 통신</code>(IPC, Inter-Process, Communication)을 사용<ul><li>파이프, 파일, 소켓 등을 사용</li></ul></li></ul><hr><h3 id=상태state>상태(state)<a hidden class=anchor aria-hidden=true href=#상태state>#</a></h3><p><img loading=lazy src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fm3Vlp%2FbtqUejFfhCh%2FX7TSK3EGxkGX8b3H7PDeFK%2Fimg.png" alt=state></p><ul><li>new : 프로세스가 처음 생성되었을 때</li><li>ready : 프로세서에게 할당되기를 기다리는 상태</li><li>running : 프로세서에 할당되어 실행되는 상태, CPU를 차지하고 있음</li><li>waiting : 작업이 완료되어 입출력을 기다리는 상태</li><li>terminated : 실행이 종료되어 프로세스 모드가 끝난 상태</li></ul><hr><h1 id=프로세스-제어-블록process-control-block-pcb>프로세스 제어 블록(Process Control Block, PCB)<a hidden class=anchor aria-hidden=true href=#프로세스-제어-블록process-control-block-pcb>#</a></h1><pre><code>    특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조
</code></pre><p><img loading=lazy src=https://blog.kakaocdn.net/dn/cjrby0/btqIarikobp/wPTdGGKemxiT7XkXXEBdQ0/img.png alt=PCB></p><ul><li>운영체제는 프로세스를 관리하기 위해 <code>프로세스의 생성과 동시에 고유한 PCB를 생성</code></li><li>프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스의 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환, 이때의 모든 작업을 PCB에 저장</li><li>다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행</li></ul><hr><h2 id=저장되는-정보>저장되는 정보<a hidden class=anchor aria-hidden=true href=#저장되는-정보>#</a></h2><ul><li>프로세스 식별자(Process ID, PID) : 프로세스 식별 번호</li><li>프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장</li><li>프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어의 주소</li><li>CPU 레지스터</li><li>CPU 스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터 등</li><li>메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보</li><li>입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록</li><li>회계(Accounting) 정보 : 사용된 CPU 양과 시간, 시간 제한, 계정 번호 등</li><li>입출력 상태 정보 : 프로세스에 할당된 입출력장치들과 열린 파일의 목록 등</li></ul><hr><h1 id=프로세스간-통신ipc-interprocess-communication>프로세스간 통신(IPC, Interprocess Communication)<a hidden class=anchor aria-hidden=true href=#프로세스간-통신ipc-interprocess-communication>#</a></h1><pre><code>    서로 다른 두 개의 프로세스가 정보를 주고 받는 방식
</code></pre><p>실행중인 다른 프로세스들에게 영향을 주거나 받지 않는 독립적인 프로세스, 다른 프로세스들에게 영향을 주거나 받는 협력적인 프로세스가 존재</p><p>IPC기법을 통해 협력적인 프로세스들은 테이터와 정보를 교환</p><hr><h2 id=공유-메모리-시스템shared-memory>공유 메모리 시스템(Shared Memory)<a hidden class=anchor aria-hidden=true href=#공유-메모리-시스템shared-memory>#</a></h2><p>기본적으로 프로세스는 서로의 영역에 침범할 수 없지만 프로세스가 이 제약조건을 제거하는 것에 동의하고 <code>공유 영역</code>에 글을 써 정보를 교환하는 방식</p><p>공유 메모리 세그먼트를 생성하는 프로세스의 주소공간에 위치시켜 통신하고자 하는 다른 프로세스들이 이 세그먼트를 자신의 주소공간에 추가하는 방법으로 사용, 동시에 공유 버퍼를 접근하는 상황때문에 동기화를 고려해야 함</p><hr><h2 id=메시지-전달-시스템message-passing-systems>메시지 전달 시스템(Message-Passing Systems)<a hidden class=anchor aria-hidden=true href=#메시지-전달-시스템message-passing-systems>#</a></h2><p>커널을 통해 메세지를 교환하기 때문에 별도의 코드를 구축할 필요가 없어 구현이 쉽지만 컨택스트 스위칭이 발생하기 때문에 속도가 느리다는 단점이 존재</p><hr><h1 id=스레드thread>스레드(Thread)<a hidden class=anchor aria-hidden=true href=#스레드thread>#</a></h1><pre><code>    한 프로세스 내에서 실행되는 여러 흐름의 단위
</code></pre><p><img loading=lazy src=https://smjeon.dev/assets/img/os/thread.png alt=Thread></p><ul><li><code>프로세스의 특정한 수행 경로</code></li><li>프로세스가 할당받은 자원을 이용하는 실행의 단위, CPU 이용의 기본 단위</li><li>프로세스 내의 주소 공간이나 자원을 공유</li><li>스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성</li><li>같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 <code>같은 운영체제 자원 공유</code></li><li>하나의 프로세스를 <code>다수의 실행단위로 구분</code>하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상하는 것 == <code>멀티 스레딩</code><ul><li>각각의 스레드는 독립적인 작업을 수행해야하기 때문에 각자의 스택과 PC 레지스터를 가진다.</li></ul></li></ul><hr><h2 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h2><ul><li>스레드는 프로세스 내에서 각각 <code>Stack과 레지스터를 따로 할당</code>받고 Code, Data, Heap 영역은 공유</li><li>한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(Sibling Thread)도 그 변경 결과를 <code>즉시 확인이 가능</code></li></ul><hr><h2 id=분류>분류<a hidden class=anchor aria-hidden=true href=#분류>#</a></h2><pre><code>    권한이 없는 스레드가 시스템 호출을 이용할 수 없도록 막기위해 종류를 나눔
</code></pre><p><strong>사용자 수준의 스레드(User Threads)</strong></p><ul><li>사용자가 만든 라이브러리를 사용하여 스레드를 운용</li><li>속도는 빠르지만 구현의 어려움</li><li>시스템 호출 권한이 없는 스레드</li></ul><hr><p><strong>커널 수준의 스레드(Kernal Threads)</strong></p><ul><li>운영체제 커널에 의해 스레드를 운용</li><li>구현은 쉽지만 유저 모드에서 커널 모드로 계속 바꿔줘야 하기 때문에 속도가 느림</li><li>시스템 호출 권한이 있는 스레드</li></ul><pre><code>    ❓스택을 스레드마다 독립적으로 할당하는 이유는❓

    스택은 함수 호출시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간
    스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것 ==&gt; 독립적인 실행 흐름의 추가

    따라서, 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 제공
</code></pre><hr><pre><code>    ❓PC Register를 스레드마다 독립적으로 할당하는 이유는❓

    PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타냄
    스레드는 CPU를 할당 받았다가 스케줄러에 의해 다시 선점당하는데, 이 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행됐는지 기록을 해야함
</code></pre><hr><h1 id=스레드-풀thread-pools>스레드 풀(Thread Pools)<a hidden class=anchor aria-hidden=true href=#스레드-풀thread-pools>#</a></h1><pre><code>웹 서버는 요청을 받을 때마다 요청을 위해 새로운 스레드를 생성
</code></pre><ul><li>프로세스를 시작할 때, <code>일정한 수의 스레드를 미리 풀로 만들어 두는 것</code></li><li>평소에는 기다리다가 요청이 들어오면 풀의 <code>한 스레드에게 서비스 요청을 할당</code></li><li>요청이 끝나면 스레드는 다시 풀로 돌아가 다음 작업을 대기</li></ul><hr><h2 id=다중-스레드-서버의-문제점>다중 스레드 서버의 문제점<a hidden class=anchor aria-hidden=true href=#다중-스레드-서버의-문제점>#</a></h2><ol><li>서비스할 때마다 스레드를 생성하는데 시간이 소요<ul><li>스레드는 주어진 일만 끝나게 되면 곧장 폐기되기 때문에 더욱 낭비</li></ul></li><li>모든 요청마다 새로운 스레드를 만들어 서비스 한다면 동시에 실행할 수 있는 최대 스레드의 한계를 정해야 함<ul><li>무한정 생성시 CPU 시간, 메모라 공건 등 시스템 자원이 고갈</li></ul></li></ol><hr><h2 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h2><ul><li>새 스레드를 만들어 주는 것보다 기존 스레드로 서비스 하는 것이 더 빠름</li><li>스레드 풀은 임의 시각에 <code>존재할 수 있는 스레드 개수에 제한</code>하기에 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 됨</li></ul><hr><h1 id=자바-스레드java-thread>자바 스레드(Java Thread)<a hidden class=anchor aria-hidden=true href=#자바-스레드java-thread>#</a></h1><ul><li>일반 스레드와 거의 차이가 없으며, JVM(Java Virtual Machine)이 운영체제 역할</li></ul><blockquote><p>JVM : OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게하는 가상 컴퓨터이다.</p></blockquote><ul><li>자바에는 <code>프로세스 단위❌, 스레드만 존재</code></li><li>자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록</li><li>스레드와 관련된 많은 정보들도 JVM에 의해 관리<ul><li>스레드의 개수</li><li>스레드로 실행되는 프로그램 코드의 메모리 위치</li><li>스레드의 상태</li><li>우선순위 등</li></ul></li><li>개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행하도록 JVM에 요청</li></ul><hr><h1 id=왜-멀티-프로세스-대신-멀티-스레드를-사용>왜 멀티 프로세스 대신 멀티 스레드를 사용???<a hidden class=anchor aria-hidden=true href=#왜-멀티-프로세스-대신-멀티-스레드를-사용>#</a></h1><p>간단히 설명하자면 프로그램을 여러개 켜는 것보다 하나의 프로그램에서 여러 작업을 하는 것!!!</p><p><img loading=lazy src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSK4Q0%2FbtqSSdeIwKt%2FE9sOA39ikYkfQjnH9tv7M0%2Fimg.png" alt=img></p><ol><li><p>응답성 증가</p><ul><li>프로그램의 일부분이 봉쇄되거나, 긴 작업을 실행하더라도 프로그램의 실행이 계속되는 것을 허용함으로써 <code>사용자에 대한 응답성을 증가</code></li></ul><blockquote><p>ex) 웹 브라우저는 한 스레드가 이미지 파일을 로드하고 있는 동안 다른 스레드에서 사용자와의 상호작용</p></blockquote></li><li><p>자원 공유 : 자원의 효율성 증가</p><ul><li><code>프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어</code> 자원을 효율적으로 관리 가능<ul><li>프로세스 간의 Context Switching시 단순히 CPU 레지스터만 교체하는 것이 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화하기 때문에 오버헤드가 큼</li></ul></li><li>스레드는 <code>프로세스 내의 메모리를 공유</code>하기 때문에 독립적인 프로세스와 달리 <code>스레드 간의 데이터를 주고 받는 것이 간단</code>해지고 시스템 자원 소모가 감소</li><li>코드와 데이터를 공유하면 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드 보유 가능</li></ul></li><li><p>경제성 : 처리 비용 감소</p><ul><li>프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간의 통신 부담이 감소<ul><li>스레드는 Stack 영역을 제외한 모든 메모리 공유</li></ul></li><li>프로세스 생성을 위해 메모리와 자원을 할당하는 것보다 스레드를 생성하고 문맥 교환을 하는 것이 더 경제적</li><li>프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠름<ul><li>Context Switching 시 스레드는 Stack 영역만 처리!, 캐시 메모리는 비우지 않아도 됨</li></ul></li><li>스레드가 프로세스보다 경량이기 때문에 생성과 제거가 쉽다</li></ul></li><li><p>규모 가변성(Scalability)</p><ul><li>다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 실행 가능</li></ul></li></ol><hr><h2 id=멀티-스레드에서-주의할-점>멀티 스레드에서 주의할 점<a hidden class=anchor aria-hidden=true href=#멀티-스레드에서-주의할-점>#</a></h2><ol><li><p>동기화 문제</p><ul><li>스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 사용시 충돌 발생 가능</li><li>사용 중인 변수나 자료구조에 접근하여 잘못된 값을 읽어오거나 수정할 수 있음</li><li>동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤해야 함<blockquote><p>But, 병목 현상이 발생해 성능 저하 가능성 있음</p></blockquote></li></ul></li><li><p>멀티 스레드는 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점을 가지고 있지만, <code>오류로 인해 하나의 스레드가 종료 시 전체 스레드가 종료될 수 있음</code></p></li></ol><hr><h1 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h1><p>CPU가 해당 프로세스를 실행하기 위한 해당 <code>프로세스들의 정보</code></p><blockquote><p>프로세스의 PCB에 저장함</p></blockquote><hr><h1 id=context-switching>Context Switching<a hidden class=anchor aria-hidden=true href=#context-switching>#</a></h1><p>현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 상태의 Task의 저장된 상태 값을 읽어 복구하는 작업</p><blockquote><p>Context Switcjing이 진행되는 동안 시스템은 아무런 유용한 일도 하지 못하기 때문에 순수한 오버헤드</p></blockquote><hr><h2 id=이유>이유<a hidden class=anchor aria-hidden=true href=#이유>#</a></h2><ul><li><p>하나의 Task만 처리할 수 있다면?</p><ul><li>해당 Task가 끝날 때까지 기다려야 함</li><li>반응 속도가 느리고 사용하기 불편함</li></ul></li><li><p>동시에 사용하는 것처럼 하기 위해</p><ul><li>Computer Multitasking</li><li>빠른 속도로 Task를 바꿔가며 실행하기 때문에 사람의 눈으로는 실시간처럼 보임</li><li>CPU가 Task를 바꿔가며 실행하기 위해 Context Switching이 필요</li></ul></li></ul><hr><h2 id=과정>과정<a hidden class=anchor aria-hidden=true href=#과정>#</a></h2><ol><li>Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리</li><li>현재 실행하고 있는 Task의 PCB 정보를 저장(Process Stack, Ready Queue)</li><li>다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행</li></ol><hr><h2 id=context-switching-cost>Context Switching Cost<a hidden class=anchor aria-hidden=true href=#context-switching-cost>#</a></h2><ul><li><p>많은 Cost가 필요</p><ul><li>Cache 초기화</li><li>Memory Mapping 초기화</li><li>Kernel은 항상 실행되어야 함(메모리의 접근을 막기 위해)</li></ul></li><li><p>Process vs Thread</p><ul><li>Process Context switching Cost > Thread Context Switching Cost</li><li>Thread는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 수행시 <code>Stack 영역만 변경</code>하면 되기 때문에 비용이 적음</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mapoalaba.github.io/tags/cs/>CS</a></li><li><a href=https://mapoalaba.github.io/tags/coumputer-science/>Coumputer Science</a></li><li><a href=https://mapoalaba.github.io/tags/os/>OS</a></li></ul><nav class=paginav><a class=next href=https://mapoalaba.github.io/posts/os-01/><span class=title>Next »</span><br><span>[CS 개념] 운영체제 (1)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on twitter" href="https://twitter.com/intent/tweet/?text=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29&amp;url=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f&amp;hashtags=CS%2cCoumputerScience%2cOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f&amp;title=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29&amp;summary=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29&amp;source=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f&title=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on whatsapp" href="https://api.whatsapp.com/send?text=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29%20-%20https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [CS 개념] 운영체제 (2) on telegram" href="https://telegram.me/share/url?text=%5bCS%20%ea%b0%9c%eb%85%90%5d%20%ec%9a%b4%ec%98%81%ec%b2%b4%ec%a0%9c%20%282%29&amp;url=https%3a%2f%2fmapoalaba.github.io%2fposts%2fcs-01%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://mapoalaba.github.io/>마포알라바 블로그</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>